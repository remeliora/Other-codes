#include <iostream>
using namespace std;
#define Max 100000000

int main()
{
    unsigned short int n;
    unsigned short int s;
    unsigned short int f;
    cin >> n;
    cin >> s;
    cin >> f;
    s--; 
    f--;

    // создаем матрицу смежности
    int** graph = new int* [n];
    for (int i = 0; i < n; i++)
        graph[i] = new int[n];
    // заполняем 
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> graph[i][j];

    // массив кратчайших растояний t[n] заполняем MAX
    // x[n] заполняем 0
    unsigned long int* t = new unsigned long int[n];
    bool *x = new bool[n];
    for (int v = 0; v < n; v++)
    {
        t[v] = Max;
        x[v] = 0;
    }

    // в каждом массиве отмечаем вершину-начало
    t[s] = 0;   // кратчайшее рассотяние для s 0, у др бесконечность
    x[s] = 1;   // массив посещенныъ вершин
    
    int v = s;
    // проходимся по графу
    while (true)
    {
        for (int u = 0; u < n; u++)
            // если из вершины s в эту вершину есть ребро
            if (graph[v][u] > 0)
                // если мы не были в вершине
                // и t вершины > t[s] + вес ребра (-//-)
                if (x[u] == 0 && t[u] >= t[v] + graph[v][u])
                    // меняем MAX 
                    // Каждой из рассмотренных вершин назначим метку равную 
                    // сумме минимальной метки W и длины пути из W в рассматриваемую вершину,
                    // если полученная сумма будет меньше предыдущего значения метки. 
                    // Иначе оставляем предыдущую метку без изменений
                    t[u] = t[v] + graph[v][u];
        int m = Max;    // минимальная метка вершины
        v = -1;         // следующая вершина
        
        for (int u = 0; u < n; u++)
            // если не были в вершине
            // и метка меньше предыдущей
            if (x[u] == 0 && m > t[u])
            {
                v = u;      // пойдем в эту вершину
                m = t[u];   // запомним минимальную метку
            }
        
        // заканчиваем цикл, если нашли решение или оно не сущ
        if (v == -1 || v == f) break;
        
        // отмечаем, что вершина пройдена
        x[v] = 1;
    }

    // вывод
    if (v == -1) cout << -1 << endl;
    else cout << t[f];
    
    // очищаем память
    for (int i = 0; i < n; i++)
        delete[] graph[i];
    delete[] graph;

    return 0;
}